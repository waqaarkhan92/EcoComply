/**
 * Obligation Audit Trail Endpoint
 * GET /api/v1/obligations/{obligationId}/audit - Get complete audit trail for obligation
 */

import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase/server';
import { successResponse, errorResponse, ErrorCodes } from '@/lib/api/response';
import { requireAuth, getRequestId } from '@/lib/api/middleware';
import { addRateLimitHeaders } from '@/lib/api/rate-limit';

export async function GET(
  request: NextRequest, props: { params: Promise<{ obligationId: string } }
) {
  const requestId = getRequestId(request);

  try {
    // Require authentication
    const authResult = await requireAuth(request);
    if (authResult instanceof NextResponse) {
      return authResult;
    }
    const { user } = authResult;

    const params = await props.params;
    const { obligationId } = params;

    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(obligationId)) {
      return errorResponse(
        ErrorCodes.VALIDATION_ERROR,
        'Invalid obligation ID format',
        400,
        { obligation_id: 'Must be a valid UUID' },
        { request_id: requestId }
      );
    }

    // Verify obligation exists and user has access (RLS will enforce)
    const { data: obligation, error: obligationError } = await supabaseAdmin
      .from('obligations')
      .select('id, company_id, created_at, updated_at')
      .eq('id', obligationId)
      .is('deleted_at', null)
      .maybeSingle();

    if (obligationError || !obligation) {
      return errorResponse(
        ErrorCodes.NOT_FOUND,
        'Obligation not found',
        404,
        null,
        { request_id: requestId }
      );
    }

    // Get all audit logs related to this obligation
    const { data: auditLogs, error: logsError } = await supabaseAdmin
      .from('audit_logs')
      .select(`
        id,
        action_type,
        entity_type,
        entity_id,
        previous_values,
        new_values,
        user_id,
        ip_address,
        user_agent,
        session_id,
        company_id,
        created_at
      `)
      .eq('entity_type', 'obligation')
      .eq('entity_id', obligationId)
      .order('created_at', { ascending: true });

    if (logsError) {
      console.error('Error fetching audit trail:', logsError);
      return errorResponse(
        ErrorCodes.INTERNAL_ERROR,
        'Failed to fetch audit trail',
        500,
        { error: logsError.message || 'Unknown error' },
        { request_id: requestId }
      );
    }

    // Also check for related entity audit logs (deadlines, evidence links, etc.)
    const { data: relatedLogs, error: relatedError } = await supabaseAdmin
      .from('audit_logs')
      .select('*')
      .eq('company_id', obligation.company_id)
      .or(`entity_id.eq.${obligationId},previous_values->>obligation_id.eq.${obligationId},new_values->>obligation_id.eq.${obligationId}`)
      .order('created_at', { ascending: true });

    if (relatedError) {
      console.error('Error fetching related audit logs:', relatedError);
    }

    // Get user details
    const allLogs = [...(auditLogs || []), ...(relatedLogs || [])];
    const userIds = [...new Set(allLogs.map((log: any) => log.user_id).filter(Boolean))];
    const { data: users } = userIds.length > 0
      ? await supabaseAdmin
          .from('users')
          .select('id, email, full_name')
          .in('id', userIds)
      : { data: [] };

    const userMap = new Map((users || []).map((u: any) => [u.id, u]));

    // Format audit trail entries
    const auditTrail = allLogs
      .map((log: any) => ({
        id: log.id,
        action_type: log.action_type,
        entity_type: log.entity_type,
        entity_id: log.entity_id,
        previous_values: log.previous_values || {},
        new_values: log.new_values || {},
        user: log.user_id ? (userMap.get(log.user_id) || { id: log.user_id, email: null, full_name: null }) : null,
        ip_address: log.ip_address,
        user_agent: log.user_agent,
        session_id: log.session_id,
        timestamp: log.created_at,
      }))
      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

    const response = successResponse(
      {
        obligation_id: obligationId,
        created_at: obligation.created_at,
        last_updated_at: obligation.updated_at,
        audit_trail: auditTrail,
        total_events: auditTrail.length,
      },
      200,
      { request_id: requestId }
    );
    return await addRateLimitHeaders(request, user.id, response);
  } catch (error: any) {
    console.error('Get obligation audit trail error:', error);
    return errorResponse(
      ErrorCodes.INTERNAL_ERROR,
      'An unexpected error occurred',
      500,
      { error: error.message || 'Unknown error' },
      { request_id: requestId }
    );
  }
}

