/**
 * Deadline Complete Endpoint
 * PUT /api/v1/deadlines/{deadlineId}/complete - Mark deadline as completed
 */

import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase/server';
import { successResponse, errorResponse, ErrorCodes } from '@/lib/api/response';
import { requireAuth, requireRole, getRequestId } from '@/lib/api/middleware';
import { addRateLimitHeaders } from '@/lib/api/rate-limit';

export async function PUT(
  request: NextRequest, props: { params: Promise<{ deadlineId: string } }
) {
  const requestId = getRequestId(request);

  try {
    // Require Owner, Admin, or Staff role
    const authResult = await requireRole(request, ['OWNER', 'ADMIN', 'STAFF']);
    if (authResult instanceof NextResponse) {
      return authResult;
    }
    const { user } = authResult;

    const params = await props.params;
    const { deadlineId } = params;

    // Parse request body
    let completionNotes: string | undefined;
    try {
      const body = await request.json().catch(() => ({}));
      completionNotes = body.completion_notes;
    } catch {
      // Body is optional
    }

    // Get deadline
    const { data: deadline, error: getError } = await supabaseAdmin
      .from('deadlines')
      .select('*')
      .eq('id', deadlineId)
      .single();

    if (getError || !deadline) {
      if (getError?.code === 'PGRST116') {
        return errorResponse(
          ErrorCodes.NOT_FOUND,
          'Deadline not found',
          404,
          null,
          { request_id: requestId }
        );
      }
      return errorResponse(
        ErrorCodes.INTERNAL_ERROR,
        'Failed to fetch deadline',
        500,
        { error: getError?.message || 'Unknown error' },
        { request_id: requestId }
      );
    }

    // Determine if deadline is late
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const dueDate = new Date(deadline.due_date);
    const isLate = today > dueDate;

    // Update deadline status
    const updates: any = {
      status: isLate ? 'LATE_COMPLETE' : 'COMPLETED',
      completed_at: new Date().toISOString(),
      completed_by: user.id,
      is_late: isLate,
      updated_at: new Date().toISOString(),
    };

    if (completionNotes !== undefined) {
      updates.completion_notes = completionNotes;
    }

    const { data: updatedDeadline, error: updateError } = await supabaseAdmin
      .from('deadlines')
      .update(updates)
      .eq('id', deadlineId)
      .select('id, status, completed_at, completed_by, completion_notes, updated_at')
      .single();

    if (updateError || !updatedDeadline) {
      return errorResponse(
        ErrorCodes.INTERNAL_ERROR,
        'Failed to update deadline',
        500,
        { error: updateError?.message || 'Unknown error' },
        { request_id: requestId }
      );
    }

    // Update schedule's last_completed_date if this is the most recent completion
    const { data: schedule } = await supabaseAdmin
      .from('schedules')
      .select('id, last_completed_date')
      .eq('id', deadline.schedule_id)
      .single();

    if (schedule) {
      const currentLastCompleted = schedule.last_completed_date 
        ? new Date(schedule.last_completed_date) 
        : undefined;
      const completedDate = new Date(deadline.due_date);

      // Update if this completion is more recent
      if (!currentLastCompleted || completedDate > currentLastCompleted) {
        await supabaseAdmin
          .from('schedules')
          .update({
            last_completed_date: deadline.due_date,
            updated_at: new Date().toISOString(),
          })
          .eq('id', deadline.schedule_id);
      }
    }

    const response = successResponse(updatedDeadline, 200, { request_id: requestId });
    return await addRateLimitHeaders(request, user.id, response);
  } catch (error: any) {
    console.error('Complete deadline error:', error);
    return errorResponse(
      ErrorCodes.INTERNAL_ERROR,
      'An unexpected error occurred',
      500,
      { error: error.message || 'Unknown error' },
      { request_id: requestId }
    );
  }
}

