/**
 * User Roles Endpoints
 * GET /api/v1/users/{userId}/roles - List user roles
 * POST /api/v1/users/{userId}/roles - Assign role to user
 */

import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase/server';
import { successResponse, errorResponse, ErrorCodes } from '@/lib/api/response';
import { requireAuth, requireRole, getRequestId } from '@/lib/api/middleware';
import { addRateLimitHeaders } from '@/lib/api/rate-limit';

export async function GET(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  const requestId = getRequestId(request);

  try {
    // Require authentication
    const authResult = await requireAuth(request);
    if (authResult instanceof NextResponse) {
      return authResult;
    }
    const { user: currentUser } = authResult;

    const { userId } = params;

    // Users can view their own roles, or Admins can view any user's roles in their company
    if (userId !== currentUser.id && !currentUser.roles.includes('OWNER') && !currentUser.roles.includes('ADMIN')) {
      return errorResponse(
        ErrorCodes.FORBIDDEN,
        'Insufficient permissions',
        403,
        null,
        { request_id: requestId }
      );
    }

    // Check if user exists
    const { data: user, error: userError } = await supabaseAdmin
      .from('users')
      .select('id, company_id')
      .eq('id', userId)
      .is('deleted_at', null)
      .single();

    if (userError || !user) {
      return errorResponse(
        ErrorCodes.NOT_FOUND,
        'User not found',
        404,
        null,
        { request_id: requestId }
      );
    }

    // Verify user has access (same company or own user)
    if (user.company_id !== currentUser.company_id && userId !== currentUser.id) {
      return errorResponse(
        ErrorCodes.FORBIDDEN,
        'Insufficient permissions',
        403,
        null,
        { request_id: requestId }
      );
    }

    // Get user roles
    const { data: roles, error: rolesError } = await supabaseAdmin
      .from('user_roles')
      .select('role, assigned_at')
      .eq('user_id', user.id);

    if (rolesError) {
      return errorResponse(
        ErrorCodes.INTERNAL_ERROR,
        'Failed to fetch user roles',
        500,
        { error: rolesError.message },
        { request_id: requestId }
      );
    }

    const response = successResponse(
      (roles || []).map((r: any) => ({
        role: r.role,
        assigned_at: r.assigned_at,
      })),
      200,
      { request_id: requestId }
    );
    return await addRateLimitHeaders(request, currentUser.id, response);
  } catch (error: any) {
    console.error('Get user roles error:', error);
    return errorResponse(
      ErrorCodes.INTERNAL_ERROR,
      'An unexpected error occurred',
      500,
      { error: error.message || 'Unknown error' },
      { request_id: requestId }
    );
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  const requestId = getRequestId(request);

  try {
    // Require Owner or Admin role
    const authResult = await requireRole(request, ['OWNER', 'ADMIN']);
    if (authResult instanceof NextResponse) {
      return authResult;
    }
    const { user: currentUser } = authResult;

    const { userId } = params;

    // Parse request body
    const body = await request.json();

    // Validate required fields
    if (!body.role || typeof body.role !== 'string') {
      return errorResponse(
        ErrorCodes.VALIDATION_ERROR,
        'Role is required',
        422,
        { role: 'Role is required' },
        { request_id: requestId }
      );
    }

    // Validate role value
    const validRoles = ['OWNER', 'ADMIN', 'STAFF', 'CONSULTANT', 'VIEWER'];
    if (!validRoles.includes(body.role)) {
      return errorResponse(
        ErrorCodes.VALIDATION_ERROR,
        'Invalid role',
        422,
        { role: `Role must be one of: ${validRoles.join(', ')}` },
        { request_id: requestId }
      );
    }

    // Check if user exists
    const { data: user, error: userError } = await supabaseAdmin
      .from('users')
      .select('id, company_id')
      .eq('id', userId)
      .is('deleted_at', null)
      .single();

    if (userError || !user) {
      return errorResponse(
        ErrorCodes.NOT_FOUND,
        'User not found',
        404,
        null,
        { request_id: requestId }
      );
    }

    // Verify user has access to this company
    if (user.company_id !== currentUser.company_id) {
      return errorResponse(
        ErrorCodes.FORBIDDEN,
        'You do not have access to this user',
        403,
        null,
        { request_id: requestId }
      );
    }

    // Check if role already assigned
    const { data: existingRole } = await supabaseAdmin
      .from('user_roles')
      .select('id')
      .eq('user_id', user.id)
      .eq('role', body.role)
      .single();

    if (existingRole) {
      return errorResponse(
        ErrorCodes.ALREADY_EXISTS,
        'Role is already assigned to this user',
        409,
        { role: 'Role is already assigned to this user' },
        { request_id: requestId }
      );
    }

    // Assign role
    const { data: roleAssignment, error: roleError } = await supabaseAdmin
      .from('user_roles')
      .insert({
        user_id: userId,
        role: body.role,
        assigned_at: new Date().toISOString(),
      })
      .select('role, assigned_at')
      .single();

    if (roleError || !roleAssignment) {
      return errorResponse(
        ErrorCodes.INTERNAL_ERROR,
        'Failed to assign role to user',
        500,
        { error: roleError?.message || 'Unknown error' },
        { request_id: requestId }
      );
    }

    const response = successResponse(
      {
        role: roleAssignment.role,
        assigned_at: roleAssignment.assigned_at,
      },
      201,
      { request_id: requestId }
    );
    return await addRateLimitHeaders(request, currentUser.id, response);
  } catch (error: any) {
    console.error('Assign role to user error:', error);
    return errorResponse(
      ErrorCodes.INTERNAL_ERROR,
      'An unexpected error occurred',
      500,
      { error: error.message || 'Unknown error' },
      { request_id: requestId }
    );
  }
}
